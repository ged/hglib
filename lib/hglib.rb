# -*- ruby -*-
# frozen_string_literal: true

require 'e2mmap'
require 'loggability'
require 'pathname'


# Toplevel namespace
module Hglib
	extend Loggability,
	       Exception2MessageMapper

	# Package version
	VERSION = '0.3.0'

	# Version control revision
	REVISION = %q$Revision$

	# The default path to the `hg` command
	DEFAULT_HG_PATH = begin
		paths = ENV['PATH'].
			split( File::PATH_SEPARATOR ).
			map {|dir| Pathname(dir) + 'hg' }

		paths.find( &:executable? ) || Pathname( '/usr/bin/hg' )
	end


	# Base exception class for errors raised by this library
	def_exception :Error, "hglib error"


	class CommandError < Hglib::Error

		def initialize( args )
			@command = args.shift
			@messages = args.flatten.map( &:chomp )
			@messages << "error in hg command" if @messages.empty?
		end

		##
		# The command that resulted in an error
		attr_reader :command

		##
		# The Array of error messages generated by the command
		attr_reader :messages


		### Returns +true+ if the command resulted in more than one error message.
		def multiple?
			return self.messages.length > 1
		end


		### Overridden to for multi-message errors.
		def message
			msg = String.new( encoding: 'utf-8' )

			msg << "`%s`:" % [ self.command ]

			if self.multiple?
				self.messages.each do |errmsg|
					msg << "\n" << '  - ' << errmsg
				end
				msg << "\n"
			else
				msg << ' ' << self.messages.first
			end

			return msg
		end

	end # class CommandError


	# Loggability API -- set up a Logger for Hglib objects
	log_as :hglib


	### Return the currently-configured path to the `hg` binary./
	def self::hg_path
		return @hg_path ||= DEFAULT_HG_PATH
	end


	### Set the path to the `hg` binary that will be used for any new commands.
	def self::hg_path=( new_path )
		@hg_path = Pathname( new_path )
	end


	# Set up automatic loading of submodules
	autoload :Config, 'hglib/config'
	autoload :Server, 'hglib/server'
	autoload :Repo, 'hglib/repo'


	### Return an Hglib::Server started with no repository.
	def self::server
		return @hg_server ||= Hglib::Server.new( nil )
	end


	### Shut down and remove the ::server if one exists. Mostly used for testing.
	def self::reset_server
		if ( server = @hg_server )
			@hg_server = nil
			server.stop
		end
	end


	### Returns +true+ if the specified +dir+ looks like it is a Mercurial
	### repository.
	def self::is_repo?( dir )
		dir = Pathname( dir )
		hgdir = dir + '.hg'
		return dir.directory? && hgdir.directory?
	end


	### Return an Hglib::Repo object for the specified +path+.
	def self::repo( path='.' )
		return Hglib::Repo.new( path )
	end


	### Clone the +source_repo+ to the specified +local_dir+, which defaults to a
	### directory with the basename of the +source_repo+ in the current working
	### directory.
	def self::clone( source_repo, local_dir=nil, **options )
		output = self.server.run( :clone, source_repo, local_dir, **options )
		self.log.debug "Clone output: %s" % [ output ]

		local_dir ||= Pathname.pwd + File.basename( source_repo )
		return self.repo( local_dir )
	end


	### Initialize a repository in the given +dir+ and return a Hglib::Repo
	### for it.
	def self::init( dir, **options )
		output = self.server.run( :init, dir, **options )
		self.log.debug "Init output: %s" % [ output ]

		return self.repo( dir )
	end


	### Fetch a Hash of version information about the Mercurial that is being used.
	def self::versions
		response = self.server.run_with_json_template( :version )
		self.logger.debug "Got a VERSION response: %p" % [ response ]

		return response.first
	end


	### Fetch the version of Mercurial that's being used as a String.
	def self::version
		return self.versions[ :ver ]
	end


	### Fetch the version of the Mercurial extensions that're being used as a Hash.
	def self::extension_versions
		ext_info = self.versions[ :extensions ]
		return ext_info.each_with_object({}) do |ext, hash|
			hash[ ext.delete(:name).to_sym ] = ext
		end
	end

end # module Hglib

